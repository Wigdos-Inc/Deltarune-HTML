<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="icon" type="x-icon" href="favicon.png">
    <title>Deltarune Chapter 1</title>
    <link rel="stylesheet" href="chapter1.css">
  </head>
  <body>
    <canvas
      class="emscripten"
      id="canvas"
      oncontextmenu="event.preventDefault()"
      tabindex="-1">
    </canvas>
    <div id="pauseMenuContainer" hidden>
      <div id="pauseMenuBorder">
        <div id="pauseMenu">
          <button id="resumeButton" onclick="resume()">
            Resume
          </button>
          <button id="quitButton" onclick="quitIfSupported()">
            Back
          </button>
        </div>
        </div>
    </div>
    <div class="loading">
      <div class="spinner" id="spinner"></div>
      <div class="emscripten" id="status">Downloading...</div>
      <progress value="0" max="100" id="progress" hidden="1"></progress>
    </div>
    <div class="output-container" id="output-container">
    </div>
    <div id="message-container">
      <div id="messages">
      </div>
    </div>
    <script type="text/javascript">
      const chapterMatch = document.title.match(/Chapter (\d+)/);
      const chapterNum = chapterMatch ? chapterMatch[1] : '1';

            function mergeFiles(fileParts) {
                return new Promise((resolve, reject) => {
                    let buffers = [];
                    function fetchPart(index) {
                        if (index >= fileParts.length) {
                            let mergedBlob = new Blob(buffers);
                            let mergedFileUrl = URL.createObjectURL(mergedBlob);
                            resolve(mergedFileUrl);
                            return;
                        }
                        // Fetch parts relative to the current chapter directory (do not double-prefix)
                        fetch(fileParts[index]).then((response) => response.arrayBuffer()).then((data) => {
                            buffers.push(data);
                            fetchPart(index + 1);
                        }).catch(reject);
                    }
                    fetchPart(0);
                });
            }

            function getParts(file, start, end) {
                let parts = [];
                for (let i = start; i <= end; i++) {
                    parts.push(file + ".part" + i);
                }
                return parts;
            }        
            Promise.all([
              mergeFiles(getParts("game.unx", 1, 1)),
              mergeFiles(getParts("runner.data", 1, 1))
            ]).then(([gameunx, runnerdata]) => {
                  // Ensure window.origin exists (some embedded contexts may not set it)
                  if (typeof window.origin === 'undefined' && typeof window.location !== 'undefined') {
                    try { window.origin = window.location.origin; } catch(e) { window.origin = window.location.protocol + '//' + window.location.host; }
                  }
                window.gameUnxUrl = gameunx;
                const originalFetch = window.fetch;
                window.fetch = async function (url, ...args) {
                  // Debug: detect suspicious URLs (e.g., 'undefined/pages/home.html')
                  try {
                    if (typeof url === 'string' && (url.includes('undefined') || url.includes('/pages/'))) {
                      console.error('Suspicious fetch URL intercepted (chapter1):', url);
                      console.trace();
                    }
                  } catch (e) { /* ignore debug logging failures */ }
                  if (url.endsWith("game.unx")) {
                      return originalFetch(gameunx, ...args);
                  } else if (url.endsWith("runner.data")) {
                      return originalFetch(runnerdata, ...args);
                  } else {
                      try {
                        if (typeof url === 'string' && (url.startsWith('undefined/') || url.includes('/undefined/'))) {
                          console.warn('Rewriting suspicious fetch URL (chapter1):', url);
                          console.trace();
                          url = (window.location && window.location.origin ? window.location.origin : '') + '/' + url.replace(/^undefined\//, '');
                        }
                      } catch(e){}
                      return originalFetch.call(this, url, ...args);
                  }
                };
                const originalOpen = XMLHttpRequest.prototype.open;
                XMLHttpRequest.prototype.open = function (method, url, ...rest) {
                    if (url.includes("game.unx")) {
                        url = window.gameUnxUrl;
                    } else if (url.includes("runner.data")) {
                      url = runnerdata;
                    }
                    return originalOpen.call(this, method, url, ...rest);
                };
                
                let migration = document.createElement("script");
                migration.src = "savesync.js";
                document.body.appendChild(migration);

                let index = document.createElement("script");
                index.src = "index.js";
                document.body.appendChild(index);
                
                let runner = document.createElement("script");
                runner.src = "runner.js";
                document.body.appendChild(runner);

            }).catch(error => {
                console.error("Failed to merge files:", error);
            });
          </script>
  </body>
</html>
