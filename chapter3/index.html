<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="icon" type="x-icon" href="/chapter3/favicon.png">
    <title>Deltarune Chapter 3</title>
    <link rel="stylesheet" href="/chapter3/chapter3.css">
  </head>
  <body>
    <canvas
      class="emscripten"
      id="canvas"
      oncontextmenu="event.preventDefault()"
      tabindex="-1"
    >
    </canvas>
    <div id="pauseMenuContainer" hidden>
      <div id="pauseMenuBorder">
        <div id="pauseMenu">
          <button id="resumeButton" onclick="resume()">
            Resume
          </button>
          <button id="quitButton" onclick="quitIfSupported()">
            Back
          </button>
        </div>
        </div>
    </div>
    <div class="loading">
      <div class="spinner" id="spinner"></div>
      <div class="emscripten" id="status">Downloading...</div>

      <progress value="0" max="100" id="progress" hidden="1"></progress>
    </div>
    <div class="output-container" id="output-container">
    </div>
    <div id="message-container">
      <div id="messages">
      </div>
    </div>
      <script type="text/javascript">
        // Detect the current chapter folder from the page title or use a default
        const chapterMatch = document.title.match(/Chapter (\d+)/);
        const chapterNum = chapterMatch ? chapterMatch[1] : '1';
        const basePath = `chapter${chapterNum}/`;

        function mergeFiles(fileParts) {
            return new Promise((resolve, reject) => {
                let buffers = [];
                function fetchPart(index) {
                    if (index >= fileParts.length) {
                        let mergedBlob = new Blob(buffers);
                        let mergedFileUrl = URL.createObjectURL(mergedBlob);
                        resolve(mergedFileUrl);
                        return;
                    }
                    // Add basePath to each file part
                    fetch(basePath + fileParts[index]).then((response) => response.arrayBuffer()).then((data) => {
                        buffers.push(data);
                        fetchPart(index + 1);
                    }).catch(reject);
                }
                fetchPart(0);
            });
        }

        function getParts(file, start, end) {
            let parts = [];
            for (let i = start; i <= end; i++) {
                parts.push(file + ".part" + i);
            }
            return parts;
        }        
        Promise.all([
          mergeFiles(getParts("game.unx", 1, 8)),
          mergeFiles(getParts("runner.data", 1, 2))
        ]).then(([gameunx, runnerdata]) => {
            if (typeof window.origin === 'undefined' && typeof window.location !== 'undefined') {
              try { window.origin = window.location.origin; } catch(e) { window.origin = window.location.protocol + '//' + window.location.host; }
            }
            window.gameUnxUrl = gameunx;
            const originalFetch = window.fetch;
            window.fetch = async function (url, ...args) {
              try {
                if (typeof url === 'string' && (url.includes('undefined') || url.includes('/pages/'))) {
                  console.error('Suspicious fetch URL intercepted (chapter3):', url);
                  console.trace();
                }
              } catch (e) {}
              if (url.endsWith("game.unx")) {
                  return originalFetch(gameunx, ...args);
              } else if (url.endsWith("runner.data")) {
                  return originalFetch(runnerdata, ...args);
              } else {
                  try {
                    if (typeof url === 'string' && (url.startsWith('undefined/') || url.includes('/undefined/'))) {
                      console.warn('Rewriting suspicious fetch URL (chapter1):', url);
                      console.trace();
                      url = (window.location && window.location.origin ? window.location.origin : '') + '/' + url.replace(/^undefined\//, '');
                    }
                  } catch(e){}
                  return originalFetch.call(this, url, ...args);
              }
            };
            const originalOpen = XMLHttpRequest.prototype.open;
            XMLHttpRequest.prototype.open = function (method, url, ...rest) {
                if (url.includes("game.unx")) {
                    url = window.gameUnxUrl;
                } else if (url.includes("runner.data")) {
                  url = runnerdata;
                }
                return originalOpen.call(this, method, url, ...rest);
            };
            
            // Load scripts with correct path
            let index = document.createElement("script");
            index.src = basePath + "index.js";
            document.body.appendChild(index);
            
            let migration = document.createElement("script");
            migration.src = basePath + "savesync.js";
            document.body.appendChild(migration);
            
            let runner = document.createElement("script");
            runner.src = basePath + "runner.js";
            document.body.appendChild(runner);
        }).catch(error => {
            console.error("Failed to merge files:", error);
        });
      </script>
    <script>
      const originalLog = console.log;
      console.log = function(...args) {
        originalLog.apply(console, args);

        const message = args.join(' ');
        if (message.includes("Videos dont work on gamemaker web export. - breadbb")) {
          GM_pause();
          const video = document.createElement("video");
          video.src = "vid/tennaintrof1_compressed_28.mp4";
          video.style.position = "absolute";
          video.style.top = "0";
          video.style.left = "0";
          video.style.width = "100vw";
          video.style.height = "100vh";
          video.style.objectFit = "cover";
          video.style.zIndex = "9999";
          video.style.pointerEvents = "none";
          video.autoplay = true;
          video.controls = false;
          video.muted = false;
          video.playsInline = true;
          document.body.appendChild(video);
          video.addEventListener("ended", () => {
            document.body.removeChild(video);
            resume();
          });
        }
      };
    </script>
  </body>
</html>